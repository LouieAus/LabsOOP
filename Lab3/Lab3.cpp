// ========= Лабораторная работа №3 =========
// Условие:
// Создать двумерный и трёхмерный массивы и реализовать
// методы для работы с ними

#include <iostream>
#include "array2d.h"
#include "array3d.h"

int main()
{
	// ------ Примеры с Array2d ------

	// Создание двумерного массива 10 на 5
	arr2d::Array2d<int> array1({10, 5});

	// Заполнение массива числом 5
	array1.Fill(5);

	// Добавление числа 999 на позицию (2, 13)
	// (возможность выхода за границу массива также учтена в методе)
	array1.Add(999, {2, 13});

	// Добавление вектора данных в столбец 5 по оси x
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<int> data = { 1, 2, 3, 10, 11 };
	array1.AddLine(data, 5, 0);

	// Добавление вектора данных в строку 1 по оси y
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<int> data2 = { 1, 2, 3, 10, 11, 0, 22, 33, 55, 6, 7, 8, 78, 9 };
	array1.AddLine(data2, 1, 1);

	// Получение элемента из позиции (10, 2)
	// (возможность выхода за границу массива также учтена в методе)
	int* element = array1.Get({ 10, 2 });

	// Получение вектора данных из столбца 9 по оси x
	// (возможность получения пустых данных из массива, т.е. nullptr,
	// учтена в методе через std::optional:
	// std::nullopt - данных в этой позиции нет,
	// T - данные в этой позиции есть)
	std::vector<std::optional<int>> get_vec;
	get_vec = array1.GetLine(9, 0);


	// ------ Примеры с Array3d ------

	// Создание трёхмерного массива 2 на 3 на 2
	arr3d::Array3d<char> array2({ 2, 3, 2 });

	// Заполнение массива символом p
	array2.Fill('p');

	// Добавление символа t на позицию (2, 1, 3)
	// (возможность выхода за границу массива также учтена в методе)
	array2.Add('t', { 2, 1, 3 });

	// Добавление вектора данных в строку (x = 1, z = 2) вдоль оси y
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<char> input = { 'u', 'g', 'q', 'o', 'p', 'h' };
	array2.AddLine(input, { 1, 2 }, arr3d::OXZ);

	// Добавление плоскости данных в позицию 2 по оси y
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<std::vector<char>> input2 = { {'a', 'b'}, {'f', 'm'}, {'g', 'w'} };
	array2.AddPlane(input2, 2, arr3d::OY);

	// Получение элемента из позиции (1, 2, 0)
	// (возможность выхода за границу массива также учтена в методе)
	char* element2 = array2.Get({ 1, 2, 0 });

	// Получение вектора данных из строки (y = 1, z = 2) вдоль оси x
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<std::optional<char>> get_line;
	get_line = array2.GetLine({ 1, 2 }, arr3d::OYZ);

	// Получение плоскости данных из позиции 0 по оси x
	// (возможность выхода за границу массива также учтена в методе)
	std::vector<std::vector<std::optional<char>>> get_plane;
	get_plane = array2.GetPlane(0, arr3d::OX);
}